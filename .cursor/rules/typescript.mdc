---
description: 
globs: **/*.ts, **/*.tsx, **/*.d.ts
alwaysApply: false
---
# TypeScript Best Practices

## Type System

- Only use `type` and avoid using `interface` keywords when defining contracts
- Avoid using `any`, prefer `unknown` for unknown types (only in special cases where the type is truly unknown like `JSON.parse`)
- Use strict TypeScript configuration
- Leverage TypeScript's built-in utility types
- Use generics for reusable type patterns

## Naming Conventions

- Use PascalCase for type names and interfaces
- Use camelCase for variables and functions
- Use UPPER_CASE for constants
- Use descriptive names with auxiliary verbs (e.g., isLoading, hasError)

## Code Organization

- If possible, keep type definitions at the top of the file
- Export types and implementations separately
- Exports must only be at the bottom of the file
- Import types using the `import type` or `import { type foo }` syntaxes
- Do not use barrel files, avoid them at all costs per [biome.jsonc](mdc:biome.jsonc)
- All object properties should be alphabetized
- All destructured properties should be alphabetized
- All class public props/methods should be alphabetized
- All class private props/methods should be alphabetized

## Functions
- Use explicit return types for public functions
- Use arrow functions over all other function declaration syntaxes
- Implement proper error handling with custom error types when necessary
- Prefer async/await over Promises

## Best Practices
- Enable strict mode in [tsconfig.json](mdc:tsconfig.json)
- Use readonly for immutable properties
- Leverage discriminated unions for type safety

## Error Handling
- Create custom error types for domain-specific errors
- Use Result types for operations that can fail
- Implement proper error boundaries
- Use try-catch blocks with typed catch clauses
- Handle Promise rejections properly
