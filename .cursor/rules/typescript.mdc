---
description: 
globs: **/*.ts, **/*.tsx, **/*.d.ts
alwaysApply: false
---
# TypeScript Best Practices

## Type System

- Only use `type` and avoid using `interface` keywords when defining contracts
- Avoid using `any`, prefer `unknown` for unknown types (only in special cases where the type is truly unknown like `JSON.parse`)
- Use strict TypeScript configuration
- Leverage TypeScript's built-in utility types
- Use generics for reusable type patterns

## Naming Conventions

- Use PascalCase for type names and interfaces
- Use camelCase for variables and functions
- Use UPPER_CASE for constants
- Use descriptive names with auxiliary verbs (e.g., isLoading, hasError)

## Code Organization

- If possible, keep type definitions at the top of the file
- Export types and implementations separately
- All exports must be located at the bottom of the file
    - One export for type only exports. For example `export type { MyType }`
    - One export for implementation exports. For example `export { myFunction }`
    - For things that are both a type and a value type, combine the exports
        - ❌ Don't do this
        ```ts
        export type { Foo }
        export { Foo }
        ```
        - ✅ Do this instead
        ```ts
        export { Foo }
        ```
- Import types using the `import type` or `import { type foo }` syntaxes
- Do not use barrel files, avoid them at all costs per [biome.jsonc](mdc:biome.jsonc)
- All object properties should be alphabetized
- All destructured properties should be alphabetized
- All class public props/methods should be alphabetized
- All class private props/methods should be alphabetized
- Add empty lines around multiline statements for better readability

## Functions
- Use explicit return types for public functions
- Use arrow functions over all other function declaration syntaxes
- Implement proper error handling with custom error types when necessary
- Prefer async/await over Promises

## Best Practices
- Enable strict mode in [tsconfig.json](mdc:tsconfig.json)
- Use readonly for immutable properties
- Leverage discriminated unions for type safety

## Error Handling
- Create custom error types for domain-specific errors
- Use Result types for operations that can fail
- Implement proper error boundaries
- Use try-catch blocks with typed catch clauses
- Handle Promise rejections properly

## Code Formatting
- Add empty lines before and after multiline statements for better readability
  ```typescript
  // ❌ Don't do this
  if (result.isOk()) {
    const value = result.value
    return processValue(value)
  }

  // ✅ Do this instead
  if (result.isOk()) {
    const value = result.value

    return processValue(value)
  }

  // ❌ Don't do this - avoid promise chaining
  const result = Promise.all([
    fetchUserData(userId),
    fetchUserPreferences(userId)
  ]).then(([userData, preferences]) => {
    return combineUserData(userData, preferences)
  }).catch(error => {
    return handleError(error)
  })

  // ✅ Do this instead - use async/await
  try {
    const [userData, preferences] = await Promise.all([
      fetchUserData(userId),
      fetchUserPreferences(userId)
    ])

    return combineUserData(userData, preferences)
  } catch (error) {
    return handleError(error)
  }
  ```
