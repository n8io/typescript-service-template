---
description:
globs: *.ts,*.tsx,*.mjs,*.js
alwaysApply: false
---
# Function Best Practices

## Rules

1. Use explicit return types for public functions
2. Use arrow functions over other function declaration syntaxes
3. Implement proper error handling with custom error types
4. Prefer async/await over Promises

## Examples

```typescript
// ✅ Good
type User = {
  id: string;
  name: string;
};

class UserNotFoundError extends Error {
  constructor(id: string) {
    super(`User with id ${id} not found`);
  }
}

const getUser = async (id: string): Promise<User> => {
  try {
    const response = await fetch(`/api/users/${id}`);
    
    if (!response.ok) {
      throw new UserNotFoundError(id);
    }
    
    return response.json();
  } catch (error) {
    if (error instanceof UserNotFoundError) {
      throw error;
    }
    throw new Error("Failed to fetch user");
  }
};

// ❌ Bad
function getUser(id) {
  return fetch(`/api/users/${id}`)
    .then(response => {
      if (!response.ok) {
        throw new Error("User not found");
      }
      return response.json();
    })
    .catch(error => {
      throw new Error("Failed to fetch user");
    });
}
```

## Rationale

- Explicit return types improve code readability and catch type errors early
- Arrow functions provide consistent `this` binding and cleaner syntax
- Custom error types enable better error handling and type safety
- async/await makes asynchronous code more readable and easier to maintain
