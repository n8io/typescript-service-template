---
description:
globs: *.ts,*.tsx,*.mjs,*.js,*.json,*.jsonc
alwaysApply: false
---
# Code Formatting

## Rules

1. Alphabetize object properties
2. Alphabetize destructured properties
3. When working with classes, the props should be grouped and ordered accordingly:
  1. All props should be grouped together by their accessibility (`private`, `constructor`, `protected`, and `public`) then alphabetized
  2. The group order is: `private`, `constructor`, `protected`, then lastly `public`
  3. There should be a newline after each group (except for the last one)

  ```typescript
  // ❌ Bad
  class Thing {
    async doStuff() { /* ... */ }
    protected increment() { /* ... */ }
    private count: number
    constructor() {}
    public findMean() { /* ... */ }
    protected internalWork() { /* ... */ }
  }

  // ✅ Good
  class Thing {
    private count: number

    constructor() {}

    protected increment() { /* ... */ }
    protected internalWork() { /* ... */ }
    
    public findMean() { /* ... */ }
    
    async doStuff() { /* ... */ }
  }
  ```

4. Add empty lines around multiline statements
5. There should always be a newline before `return`, `break`, and `continue` statements
6. There should always be a newline before multiline statements unless the statement is directly after a closing brace
7. There should always be a newline after multiline statements unless the statement is directly followed by a closing brace
8. Avoid promise chaining
9. Group variable definitions closely together and add empty lines before and after each variable definition group

## Examples

```typescript
// ❌ Bad
const config = {
  timeout: 5000,
  apiKey: "123",
  version: "1.0",
  endpoint: "https://api.example.com"
};

class UserService {
  private readonly logger: Logger;
  private readonly apiClient: ApiClient;

  constructor(apiClient: ApiClient, logger: Logger) {
    this.apiClient = apiClient;
    this.logger = logger;
  }

  async getUser(id: string): Promise<User> {
    return this.apiClient.get(`/users/${id}`)
      .then(response => {
        this.logger.info("User fetched", { id });
        return response.data;
      });
  }
}

// ✅ Good
const config = {
  apiKey: "123",
  endpoint: "https://api.example.com",
  timeout: 5000,
  version: "1.0"
};

class UserService {
  private readonly apiClient: ApiClient;
  private readonly logger: Logger;

  constructor(apiClient: ApiClient, logger: Logger) {
    this.apiClient = apiClient;
    this.logger = logger;
  }

  async getUser(id: string): Promise<User> {
    const response = await this.apiClient.get(`/users/${id}`);

    this.logger.info("User fetched", { id });

    return response.data;
  }
}
```

## Rationale

- Alphabetized properties make code more maintainable and easier to scan
- Empty lines improve readability by separating logical blocks
- Avoiding promise chaining makes code more readable and easier to debug
- Consistent formatting makes code reviews easier and reduces merge conflicts
