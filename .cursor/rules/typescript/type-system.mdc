---
description:
globs: *.ts,*.tsx,*.mjs,*.js
alwaysApply: false
---
# Type System Best Practices

## Rules

1. Use `type` instead of `interface` for defining contracts
2. Use `unknown` instead of `any` for unknown types (except in special cases like `JSON.parse`)
3. Enable strict TypeScript configuration
4. Leverage TypeScript's built-in utility types
5. Use generics for reusable type patterns
6. Never create a `types` directory. Types, interfaces, models, and schemas should all live under an appropriately scoped `models` directory. See existing project patterns for examples.
7. Use abstract base classes that can be extended for special cases where maintaining internal state on an instance is necessary.

## Examples

```typescript
// ✅ Good
type User = {
  id: string;
  name: string;
};

// ❌ Bad
interface User {
  id: string;
  name: string;
}

// ✅ Good
function parseJSON<T>(json: string): T {
  return JSON.parse(json) as T;
}

// ❌ Bad
function parseJSON(json: string): any {
  return JSON.parse(json);
}
```

## Rationale

- `type` is more flexible and can represent unions, intersections, and mapped types more clearly
- `unknown` provides better type safety than `any` by requiring type checking before use
- Strict configuration helps catch potential errors early
- Utility types reduce boilerplate and improve type safety
- Generics enable type-safe reusable code patterns
